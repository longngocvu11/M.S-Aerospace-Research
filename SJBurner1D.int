/*******************************************************************************
Copyright 2003. The U.S. Government, as Represented by the Administrator of
the National Aeronautics and Space Administration (NASA). All rights reserved.
Includes content licensed from the U.S. Government, National Aeronautics and
Space Administration under United States Copyright Registration Numbers
V3503D364 and V3482D344.
Copyright 2008-2015 NPSS Consortium, www.NPSSConsortium.org/AllRightsReserved
*******************************************************************************/

/*******************************************************************************
NPSS software and related documentation is export controlled with an Export
Control Classification Number(ECCN) of 9D991, controlled for Anti-Terrorism
reasons, under U.S. Export Administration Regulations 15 CFR 730-774. It may
not be transferred to a country checked under anti-terrorism on the Commerce
Country Chart structure or to foreign nationals of those countries in the U.S.
or abroad without first obtaining a license from the Bureau of Industry and
Security, United States Department of Commerce. Violations are punishable by
fine, imprisonment, or both.
*******************************************************************************/
//
// For further information contact support@npssconsortium.org
//
// CONVERSION FACTORS
//
// 1 BTU/lbm -- 25037. (ft/sec)^2
// 1 psia -- 4633.056 (lbm*ft/sec^2)/ft^2 
// 1 BTU -- 25037. lbm*(ft/sec)^2
// 1 ft -- 12. inch
//
#ifndef __SJBurner1D__
#define __SJBurner1D__

#include <InterpIncludes.ncp>

class SJBurner1D extends Element {

  //------------------------------------------------------------
  //     ******* SETUP VARIABLES ********
  //------------------------------------------------------------
  // Inputs
  //------------------------------------------------------------
  // Isolator
  real Li {
	  value = 10.;	IOstatus = INPUT;	units = INCH;
	  description = "Isolator length";
  }
  int mode {
	  value = 0;	IOstatus = INPUT;	units = NONE;
	  description = "Shock train mode";
  }
  int Niatt {
	  value = 100;	IOstatus = INPUT;	units = NONE;
	  description = "Number of points";
  }
  int Nisep {
	  value = 100;	IOstatus = INPUT;	units = NONE;
	  description = "Number of points";
  }
  // Combustor
  int Nc {
	  value = 100;	IOstatus = INPUT;	units = NONE;
	  description = "Number of points";
  }
  real Lc {
	  value = 10.;	IOstatus = INPUT;	units = INCH;
	  description = "Combustor length";
  }
  // Ajet3
  real Ajet3 {
	  value = 10.;	IOstatus = INPUT;	units = INCH2;
	  description = "Fuel Jet Area at Station 3";
  }
  // For combustor diverging area 
  real a1 {
	  value = 1.;	IOstatus = INPUT;	units = INCH;
	  description = "First Coeff";
  }
  real a2 {
	  value = 1.;	IOstatus = INPUT;	units = INCH2;
	  description = "Second Coeff";
  } 
  // For Vfx
  real b1 {
	  value = 1.;	IOstatus = INPUT;	units = FT_PER_SEC2;
	  description = "First Coeff";
  }
  real b2 {
	  value = 1.;	IOstatus = INPUT;	units = FT_PER_SEC;
	  description = "Second Coeff";
  }
  // Wall Temperature
  real Tw {
	  value = 1080.;	IOstatus = INPUT;	units = RANKINE;
	  description = "Wall temperature";
  }
  // FAR stoic
  real FARstoic {
	  value = 0.0674;	IOstatus = INPUT;	units = NONE;
	  description = "Stoichiometric FAR";
  }
  real phi0 {
	  value = 0.0291;	IOstatus = INPUT;	units = NONE;
	  description = "Initial equivalence ratio";
  }
  //------------------------------------------------------------
  // Outputs
  //------------------------------------------------------------
  real Vout {
	  value = 0;	IOstatus = OUTPUT; units = FT_PER_SEC;
	  description = "Velocity";
  }
  real Psout {
	  value = 0;	IOstatus = OUTPUT; units = PSIA;
	  description = "Static Pressure";
  }
  real Tsout {
	  value = 0;	IOstatus = OUTPUT; units = RANKINE;
	  description = "Static Temperature";
  }
  /*
  real MNout {
	  value = 0;	IOstatus = OUTPUT; units = NONE;
	  description = "Mach Number";
  }
  */
  //------------------------------------------------------------
  //   ******* OPTION VARIABLE SETUP *******
  //------------------------------------------------------------
	
  //------------------------------------------------------------
  // ****** SETUP PORTS, FLOW STATIONS, SOCKETS, TABLES ********
  //------------------------------------------------------------
  
  // FLUID PORTS
  FluidInputPort Fl_I {
    description = "Incoming flow";
  }

  FluidOutputPort Fl_O {
    description = "Exiting flow";
  }
  
  // FUEL PORTS
  FuelInputPort Fu_I {
    description = "Incoming fuel flow";
  }
  // BLEED PORTS
  
  // THERMAL PORTS
  
  // MECHANICAL PORTS
  
  // FLOW STATIONS
  FlowStation Fl_Otemp;
  Fl_Otemp.setOption("switchTransport", "EQUIL");
  
  FlowStation Fstemp1;
  Fstemp1.setOption("switchTransport", "EQUIL");
  FlowStation Fstemp2;
  Fstemp2.setOption("switchTransport", "EQUIL");
  
  FlowStation fs;
  fs.setOption("switchTransport", "EQUIL");

  // SOCKETS
  
  // TABLES
  
  // DATA PORTS

  //------------------------------------------------------------
  // ******* INTERNAL SOLVER SETUP *******
  //------------------------------------------------------------
  
  //------------------------------------------------------------
  //  ******  ADD SOLVER INDEPENDENTS & DEPENDENTS  ******
  //------------------------------------------------------------
  
  //------------------------------------------------------------
  // ******* VARIABLE CHANGED METHODOLOGY *******
  //------------------------------------------------------------
  
  //------------------------------------------------------------
  //   ******* PERFORM ENGINEERING CALCULATIONS *******
  //------------------------------------------------------------
  
  void calculate() {
	// Unit conversion: All parameters from flow stations are converted into normal standard, 
	// then converted back into flow station standard if needed when inputed into flow station functions
	// ONLY L and x are allowed in inch
	real in2cf = 1./144.;
	real intoft = 1./12.;
	real mtoin = 39.3701;
	real BTUcf = 25037.;
	real psicf = 4633.056;
	real KtoR = 1.8;
	//Fl_I.Aphy = a1-Ajet3;

	real Ptin = Fl_I.Pt*psicf;
	real Psin = Fl_I.Ps*psicf;
	real htin = Fl_I.ht*BTUcf;
	real hsin = Fl_I.hs*BTUcf; // BTU/lbm to (f/s)^2
	real Ttin = Fl_I.Tt;
	real Tsin = Fl_I.Ts;
	real Vin = Fl_I.V;
	real Ain = Fl_I.Aphy*in2cf; // Ain in ft2
	real Win = Fl_I.W;
	real rhoin = Fl_I.rhos;
	real R = Fl_I.Rs*BTUcf; // BTU/lbm.R to (f/s)^2/R
	real Cp = Fl_I.Cps*BTUcf;
	real gama = Fl_I.gams;
	real MNin = Fl_I.MN;
	real Wair;
	
	real dv = Fl_I.mus;
	real D2 = (4.*Ain/3.1416)**0.5;  // in ft
	real Re2 = (rhoin*Vin*D2)/dv;
	real mt = 0.037*D2/(Re2**0.2); // in ft
	real Remt = (rhoin*Vin*mt)/dv;
	//real Ps2 = Psin;
	real MN2 = MNin;
	real Ps3; 
	
	// Test
	cout << endl;
	cout << "Re2 = " << Re2 << endl;
		
	real htintemp;
	real hsintemp;
	real Psintemp;
	
	real Ptout;
	real hsout;
	real htout;
	real gamaout;
	real Rout;
	real MNout;
	
    real FAR0;
		
	// Declare Variables
	real Awall; real dAwalldx;
	real Ajet; real dAjetdx;
	real A; real dAdx;
	
	real Dw;
	real Vfx;
	real etam;
	real detamdx;
	real dWdxW;
	real dphidx;
	real Im;
	real Ie;
	real term1; real term2; real term3; real term4;
	real D; real E; real RHS1; real RHS2;
	
	int i;
	real k1; real k2; real k3; real k4;
	real l1; real l2; real l3; real l4;
	real m1; real m2; real m3; real m4;
	
	real qw;
	real Cw;
	real pi = 3.1416;
	real Pr = 0.9;//0.72;
	real Taw;
	
	real dhtdx;
	real dhsdx;
	real dPsdx;

	real drhodP;
	real dP; real Ps1; real Ps2; real Pt1; real Pt2;
	real drhodh;
	real dh; real hs1; real hs2; real Vin1; real Vin2;
	real drhodphi;
	real dphi;
	real drhodT; 
	real dT; real Ts1; real Ts2;
	
	real sonicSpeed;
	// Step
	real x;
	real x2 = 0.;
	real xu;
	real x3 = x2+Li;
	real x4 = x3+Lc;
	real dxiatt;
	real dxisep;
	real dxc = (x4-x3)/Nc;	
	// Flag for switching
	int flag;
	int flag2;
	int sos;
	
	real Ls1, Ls2;
	// For calculating Cf
	real Cf;
	real _R = 111.*KtoR;
	real _T;
	real _C;
	real Re;
	//------------------------------------------------------------
    // Text Output Function
    //------------------------------------------------------------
	OutFileStream os_EngResultsRow {
	// Name of the output file that is created by this out stream
	filename = "cout"; // sent results to the command prompt
	//filename = "EngResults.txt";
	}
	// Create the Case Row Viewer named EngResultsRow
	DataViewer CaseRowViewer EngResultsRow {

		// Specify the OutFileStream object to use for this viewer
		outStreamHandle = "os_EngResultsRow";
		
		// Set the default number format for real and scientific notation
		defRealFormat = "????????.???????";
		defSNFormat =   "??.???????E?????";
		
		// List the variables that you want to print to the output file
		variableList = {
				"MNtext : ??.??????? = MN",
				"Vtext : ?????.??????? = V",
				"Pttext : ?????.??????? = Pt/Pt2",
				"httext : ?????????.??????? = ht/ht2",
				"Pstext : ?????.??????? = Ps/Ps2",
				"Tstext : ?????.??????? = Ts/Ts2",
				"Aphytext : ?????.??????? = Ac/A2",
				"Artext : ?????.??????? = Ac/Awall",
				"O2text : ??.???????? = O2",
				"H2Otext : ??.???????? = H2O",
				"CO2text : ??.???????? = CO2",
				"N2text : ??.???????? = N2"
			}
			
		titleBody = "";  // Title to display (if desired)
		titleVars = {};
		
		// Print the Case in the file header
		caseHeaderBody = "x ???.???????"; // Case header title to display
		caseHeaderVars = {"xtext"}; // Actual case number
		
		pageWidth = 10000;
		pageHeight = 10000.;
	}
	real xtext; 
	real MNtext; 
	real Vtext; 
	real Pttext; 
	real httext; 
	real Pstext;
	real Tstext; 
	real Aphytext;
	real Artext;
	real O2text;
	real H2Otext;
	real CO2text;
	real N2text;
	void textinitiate() {
		xtext = 0;
		MNtext = MNin; 
		Vtext = Vin; 
		Pttext = Ptin/(Fl_I.Pt*psicf);
		httext = htin/(Fl_I.ht*BTUcf);
		Pstext = Psin/(Fl_I.Ps*psicf);
		Tstext = Tsin/Fl_I.Ts;
		Aphytext = Ain/(Fl_I.Aphy*in2cf);
		Artext = Ain/calcAwall(0);
		O2text = Fl_I.getTotalComp("O2");
		H2Otext = Fl_I.getTotalComp("H2O");
		CO2text = Fl_I.getTotalComp("CO2");
		N2text = Fl_I.getTotalComp("N2");
				
		os_EngResultsRow.filename = "EngResults.txt";
		EngResultsRow.isActive = TRUE;
		EngResultsRow.update();
	}
	void textOutputUpdate(real x, real dx) {
		xtext = x+dx;
	  	MNtext = MNout; 
		Vtext = Vout; 
		Pttext = Fl_O.Pt/(Fl_I.Pt*psicf);
		httext = htout/(Fl_I.ht*BTUcf);
		Pstext = Psout/(Fl_I.Ps*psicf);
		Tstext = Tsout/Fl_I.Ts;
		Aphytext = A/(Fl_I.Aphy*in2cf);
		Artext = A/calcAwall(xtext);
		O2text = Fl_O.getTotalComp("O2");
		H2Otext = Fl_O.getTotalComp("H2O");
		CO2text = Fl_O.getTotalComp("CO2");
		N2text = Fl_O.getTotalComp("N2");
		
		os_EngResultsRow.filename = "EngResults.txt";
		EngResultsRow.isActive = TRUE;
		EngResultsRow.update();
	}
	//-----------------------------------------------------------------------------------------	
	// Initiate Function
	//-----------------------------------------------------------------------------------------
	void initiate() {
		// Reset Win
		Vin = Fl_I.V;
		rhoin = Fl_I.rhos;
		Ain = calcAwall(0.)-Ajet3*in2cf; // Ain in ft2
		Fl_I.W = Ain*rhoin*Vin;
		
		Ptin = Fl_I.Pt*psicf;
		Psin = Fl_I.Ps*psicf;
		htin = Fl_I.ht*BTUcf;
		hsin = Fl_I.hs*BTUcf; // BTU/lbm to (f/s)^2
		Ttin = Fl_I.Tt;
		Tsin = Fl_I.Ts;
		Win = Fl_I.W;
		R = Fl_I.Rs*BTUcf; // BTU/lbm.R to (f/s)^2/R
		Cp = Fl_I.Cps*BTUcf;
		gama = Fl_I.gams;
		MNin = Fl_I.MN;
		
		FAR0 = phi0*FARstoic;
		Wair = Fl_I.Wa;
		
		Fl_O.copyFlowStatic("Fl_I");
	}
	//-----------------------------------------------------------------------------------------	
	// Components Calculation Functions
	//-----------------------------------------------------------------------------------------
	real calcVfx() {
		// Assume fuel jet at the same temperature as the wall
		// Assume MNjet = 1
		// Set full flow condition after isolator
		return (Fl_O.gams*Fl_O.Rs*BTUcf*Fl_O.MW*0.5*Tw)**0.5;
	}
	//-----------------------------------------------------------------------------------------
	real Lmix;
	real K = 390.;
	real Mc;
	real fMc;
	real Df = 0.0016*mtoin;
	real rhof = 0.003;//0.00512; //H2 lbm/ft3 at 300K // 0.004509; 0.003;
	real aa;
	real af;
	real e = 2.71828;//182846;
	
	real calcLmix() {
		/*
		af = Vfx; // as Mjet = 1
		aa = (Fl_O.gams*Fl_O.Rs*BTUcf*Fl_O.Ts)**0.5;
		Mc = (Vfx-Fl_O.V)/(aa+af);
		term1 = 3.*(Mc**2);
		term2 = e**(-term1);
		fMc = 0.25+0.75*term2;	
		return ((Df*K*((rhof*Vfx)/(Fl_O.rhos*Fl_O.V))**0.5)/fMc);
		*/
		return 0.34*mtoin;;//60*0.0098*mtoin;
	}
	//-----------------------------------------------------------------------------------------
	real alpha = 1.06;
	real k = 3.69639;
	real d = 0.80586;
	real lamda = 10.;
	real etab = 1.;
	
	real calcetam(real x) {
		/*
		// etam = alpha*(1.-e**(-(k*x/Lmix)**d));
		// Group too many operations in one line will give NaN result
		term1 = (k*x)/Lmix;
		term2 = term1**d;
		term3 = e**(-term2);
		if (alpha*(1.-term3)<1.) {
			return alpha*(1.-term3);
		} else {
			return 1.;
		}
		
		if (x == 0.) {
			return 0.;
		} else {	
			term1 = 0.179*Lmix*exp(1.72*phi0);
			term2 = 1.01+0.176*log(x/term1);
			if (term2 < 1.) {
				return term2;
			} else {
				return 1.;
			}
		}
		
		term1 = x/Lmix;
		term2 = 1./(50.+1000.*0.25);
		term3 = (term1+term2)**0.25;
		if (term3 < 1.) {
			return term3;
		} else {
			return 1.;
		}
		
		term1 = etab*lamda*(x-x3)/(Lmix+(lamda-1.)*(x-x3));
		if (term1 < 1.) {
			return term1;
		} else {
			return 1.;
		}
		*/
		return 0.;
	}
	//-----------------------------------------------------------------------------------------
	real calcdetamdx(real x, real dx) {
		/*
		if (x == 0.) {
			return (-3.*calcetam(x)+4.*calcetam(x+dx)-calcetam(x+2.*dx))/(2.*dx);
		} else {
			if (calcetam(x) == 1.) {
				return 0.;
			} else {
				term1 = (k*x)/Lmix;
				term2 = term1**d;
				term3 = e**(-term2);
				term4 = term1**(d-1.);
				return alpha*d*(k/Lmix)*term3*term4;
			}
		}
		
		if (calcetam(x) == 1.) {
			return 0.;
		} else {
			return (-3.*calcetam(x)+4.*calcetam(x+dx)-calcetam(x+2.*dx))/(2.*dx);
		}
		//return etab*lamda/(Lc*(1.+(lamda-1.)*((x-x3)/Lmix))**2);
		*/
		return 0.;
	}
	//-----------------------------------------------------------------------------------------
	real calcAwall(real x) {
		/*
		if (x < x3) {
			return a1*in2cf;
		} else {
			return ((a2-a1)*(x-x3)/Lc+a1)*in2cf;
		}
		*/
		if (x < 0.242*mtoin) {
			return a1*in2cf;
		} else {
			return ((a2-a1)*(x-0.242*mtoin)/(0.147*mtoin)+a1)*in2cf;
		}
	}
	//-----------------------------------------------------------------------------------------
	real calcdAwalldx(real x) {
		/*
		if (x < x3) {
			return 0.;
		} else {
			return (a2-a1)*in2cf/Lc;
		}
		*/
		if (x < 0.242*mtoin) {
			return 0.;
		} else {
			return ((a2-a1)/(0.147*mtoin))*in2cf;
		}
	}
	//-----------------------------------------------------------------------------------------	
	// Isolator - Attached Zone
	//-----------------------------------------------------------------------------------------
	void calcDeliatt(real Pt, real ht, real x, real dx) {
		
		// Test
		cout << endl;
		cout << "Ptin = " << Pt << "  ";
		
		// Calculate dA/dx: A = Acore
		// Awall(x) = (A4-A3)*x/L+A3
		Awall = calcAwall(x); // Choose combustor geometry *****************************
		// dAwall/dx
		dAwalldx = calcdAwalldx(x);
		// A
		A = Awall;  // ********************** Set A=cte for friction case
		// dA/dx
		dAdx = dAwalldx;
		
		Fl_Otemp.copyFlow("Fl_O");
		// Set ht, Pt
		Fl_Otemp.setTotal_hP(ht, Pt);
		Fl_Otemp.Aphy = A;
		Fl_Otemp.superOrSub = "SUPERSONIC";
		// Flow properties
		Tsin = Fl_Otemp.Ts;
		Psin = Fl_Otemp.Ps;
		Ptin = Fl_Otemp.Pt;
		Ain = Fl_Otemp.Aphy/144.;
		Win = Fl_Otemp.W;
		Vin = Fl_Otemp.V;
		rhoin = Fl_Otemp.rhos;
		MNin = Fl_Otemp.MN;
		R = Fl_Otemp.Rs*25037.;
		Cp = Fl_Otemp.Cps*25037.;
		hsin = Fl_Otemp.hs*25037.;
		gama = Fl_I.gams;
		// Convert units of all var except P
		
		// Test
		cout << endl;
		cout << "MNin = " << MNin << "  ";
		cout << "Vin = " << Vin << "  ";
		cout << "Tsin = " << Tsin << "  ";
		cout << "Psin = " << Psin << "  ";
		cout << "R = " << R << "  ";
		cout << "Cp = " << Cp << "  ";
		cout << "Wfuel = " << Fl_Otemp.Wf << "  ";
		cout << "Win = " << Win << "  ";
		cout << "Ain = " << Ain << "  ";
		cout << "rhoin = " << rhoin << "  ";
		cout << "hsin = " << hsin << endl;

		//-----------------------------------------------------------------------------------------
		// Calculate Im
		// Dw
		Dw = calcDw(x);
		// Im
		term1 = 0.;    // **************** 0 if friction only
		term2 = -0.5*rhoin*(Vin**2)*(Ptin/Psin)*Cf*(4./Dw);
		term3 = 0.; //-0.5*rhoin*(Vin**2)*((Fl_Otemp.Tt-Fl_O.Tt)/(Fl_Otemp.Tt*dx));
		Im = term1+term2+term3;         // ****************************************** 0 if no heat
		
		// Test
		cout << endl;
		cout << "Im term1 = " << term1 << "  ";
		cout << "Im term2 = " << term2 << "  ";
		cout << "Im = " << Im << endl;
		
		// Dpt/dx
		dPtdx = Im/4633.056;
		// Test
		cout << endl;
		cout << "dPt/dx = " << dPtdx << "  ";
		
		// Caculate qw
		Taw = Tsin*(1.+Pr**(1./3.)*(0.5*(gama-1.)*(MNin**2.)));
		qw = 0.5*rhoin*Vin*Cp*Cf*(Tw-Taw)/(Pr**(1./3.));
		Cw = pi*Dw*dx;
		dhtdx = qw*Cw/(Win*dx);
		dhtdx = dhtdx/25037.;
		// Test
		cout << endl;
		cout << "dht/dx = " << dhtdx << endl;
	}
	//-----------------------------------------------------------------------------------------	
	// Isolator - Separation zone
	//-----------------------------------------------------------------------------------------
	void calcDelisep (real Pt, real ht, real Ps, real x, real dx) {
		
		// Test
		cout << endl;
		cout << "Ptin = " << Pt << "  ";
		
		// Calculate dA/dx: A = Acore
		// Awall(x) = (A4-A3)*x/L+A3
		Awall = calcAwall(x); // Choose combustor geometry *****************************
		// dAwall/dx
		dAwalldx = calcdAwalldx(x);
		// A
		A = Awall;  // ********************** Set A=cte for friction case
		// dA/dx
		dAdx = dAwalldx;
		
		Fl_Otemp.copyFlow("Fl_O");
		// Set ht, Pt
		Fl_Otemp.setTotal_hP(ht, Pt);
		Fl_Otemp.Ps = Ps;
		// Flow properties
		Tsin = Fl_Otemp.Ts;
		Psin = Fl_Otemp.Ps;
		Ptin = Fl_Otemp.Pt;
		Ain = Fl_Otemp.Aphy/144.;
		Win = Fl_Otemp.W;
		Vin = Fl_Otemp.V;
		rhoin = Fl_Otemp.rhos;
		MNin = Fl_Otemp.MN;
		R = Fl_Otemp.Rs*25037.;
		Cp = Fl_Otemp.Cps*25037.;
		hsin = Fl_Otemp.hs*25037.;
		gama = Fl_I.gams;
		// Convert units of all var except P
		
		// Test
		cout << endl;
		cout << "MNin = " << MNin << "  ";
		cout << "Vin = " << Vin << "  ";
		cout << "Tsin = " << Tsin << "  ";
		cout << "Psin = " << Psin << "  ";
		cout << "R = " << R << "  ";
		cout << "Cp = " << Cp << "  ";
		cout << "Wfuel = " << Fl_Otemp.Wf << "  ";
		cout << "Win = " << Win << "  ";
		cout << "Ain = " << Ain << "  ";
		cout << "rhoin = " << rhoin << "  ";
		cout << "hsin = " << hsin << endl;

		//-----------------------------------------------------------------------------------------
		// Calculate Im
		// Dw
		Dw = calcDw(x);
		// Im
		term1 = 0.;    // **************** 0 if friction only
		term2 = -0.5*rhoin*(Vin**2)*(Ptin/Psin)*Cf*(4./Dw);
		term3 = 0.; //-0.5*rhoin*(Vin**2)*((Fl_Otemp.Tt-Fl_O.Tt)/(Fl_Otemp.Tt*dx));
		Im = term1+term2+term3;         // ****************************************** 0 if no heat
		
		// Test
		cout << endl;
		cout << "Im term1 = " << term1 << "  ";
		cout << "Im term2 = " << term2 << "  ";
		cout << "Im = " << Im << endl;
		
		// Dpt/dx
		dPtdx = Im/4633.056;
		// Test
		cout << endl;
		cout << "dPt/dx = " << dPtdx << "  ";
		
		// Caculate qw
		Taw = Tsin*(1.+Pr**(1./3.)*(0.5*(gama-1.)*(MNin**2.)));
		qw = 0.5*rhoin*Vin*Cp*Cf*(Tw-Taw)/(Pr**(1./3.));
		Cw = pi*Dw*dx;
		dhtdx = qw*Cw/(Win*dx);
		dhtdx = dhtdx/25037.;
		
		// Test
		cout << endl;
		cout << "dht/dx = " << dhtdx << "  ";
		
		// Calculate dPs/dx
		dPsdx = 0.5*rhoin*(Vin**2)*Cf*(89./Dw)/4633.056;
		
		// Test
		cout << endl;
		cout << "dPs/dx = " << dPsdx << endl;
	}
	//-----------------------------------------------------------------------------------------	
	// Combustor
	//-----------------------------------------------------------------------------------------
	void calcDelc(real Ps, real ht, real hs, real x, real dx, real factor, int flag, int flag2) {
		
		// Test
		cout << endl;
		cout << "INPUT:  ";
		cout << "Psin = " << Ps << "  ";
		cout << "hsin = " << hs << "  ";
		cout << "htin = " << ht << endl;
		
		// Calculate dA/dx: A = Acore
		// etam
		etam = calcetam(x); //0.8*5.*x/(L+4.*x);
		detamdx = calcdetamdx(x, dx); //0.8*5./(L*(1.+4.*(x/L))**2);  
		
		// Test
		cout << endl;
		cout << "etam = " << etam << "  ";
		cout << "detam/dx = " << detamdx << endl;
		
		// Awall(x) = (A4-A3)*x/L+A3
		Awall = calcAwall(x); // Choose combustor geometry *****************************
		// dAwall/dx
		dAwalldx = calcdAwalldx(x);
		// Ajet 
		Ajet = Ajet3*in2cf*(1.-etam); // Ajet3 INPUT ****************************************
		// dAjet/dx
		dAjetdx = -Ajet3*detamdx; 
		// A
		A = Awall-Ajet;  // ********************** Set A=cte for friction case
		// dA/dx
		dAdx = dAwalldx-dAjetdx;
		
		Fl_Otemp.copyFlow("Fl_O");
		// Burn to add fuel into flow composition, add from position x
		Fu_I.Wfuel = Wair*FAR0*calcdetamdx(x-0.5*factor*dx, dx)*dx*factor;
		Fl_Otemp.burn("Fu_I", 1.);
		// Set flow properties
		Fl_Otemp.setTotal_hP(hs/BTUcf, Ps/psicf);
		// Flow properties
		Psin = Fl_Otemp.Pt*psicf;
		hsin = Fl_Otemp.ht*BTUcf;
		Tsin = Fl_Otemp.Tt;
		Vin = (2.*(ht-hs))**0.5;
		Win = Fl_Otemp.W;
		Ain = A;
		rhoin = Fl_Otemp.rhot;
		R = Fl_Otemp.Rt*BTUcf;
		Cp = Fl_Otemp.Cpt*BTUcf;
		
		// Test
		cout << endl;
		cout << "hsin = " << hsin << "  ";
		cout << "Psin = " << Psin << "  ";
		cout << "Tsin = " << Tsin << "  ";
		cout << "Vin = " << Vin << "  ";
		cout << "Ain = " << Ain << "  ";
		cout << "rhoin = " << rhoin << "  ";
		cout << "Wfuel = " << Fl_Otemp.Wf << "  ";
		cout << "Win = " << Win << "  ";
		cout << "mu = " << Fl_Otemp.mut << endl;
		
		// Dw
		Dw = (4.*Awall/pi)**0.5;
		// Cw
		Cw = pi*Dw*dx;
		// Taw
		MNin = Vin/((gama*R*Tsin)**0.5);
		Taw = Tsin*(1.+Pr**(1./3.)*(0.5*(gama-1.)*(MNin**2.)));
		// Cf
		_T = 0.5*Tw+0.28*Tsin+0.22*Taw;
		_C = ((Tsin+_R)/(_T+_R))*(_T/Tsin)**0.5;
		Re = (rhoin*Vin*Dw)/Fl_Otemp.mut;
		Cf = 0.664*(_C/Re)**0.5;
		
		// Test
		cout << endl;
		cout << "T* = " << _T << "  ";
		cout << "C* = " << _C << "  ";
		cout << "Re = " << Re << "  ";
		cout << "Cf = " << Cf << endl;
		
		// dW/(W*dx)
		dWdxW = (FAR0*detamdx)/(1.+FAR0*etam);
		// dphidx
		dphidx = (FAR0*detamdx)/FARstoic;
		// drhodP
		Fstemp1.copyFlow("Fl_Otemp");
		Fstemp2.copyFlow("Fl_Otemp");
		// Same phi --> same ht, same hs --> same Vin
		dP = Psin*0.001;
		Ps1 = Psin-dP;
		Ps2 = Psin+dP;
		Fstemp1.setTotal_hP(hsin/BTUcf, Ps1/psicf);
		Fstemp2.setTotal_hP(hsin/BTUcf, Ps2/psicf);
		drhodP = (Fstemp2.rhot-Fstemp1.rhot)/(2.*dP);
		// drhodT
		dT = Tsin*0.001;
		Ts1 = Tsin-dT;
		Ts2 = Tsin+dT;
		Fstemp1.setTotalTP(Ts1, Psin/psicf);
		Fstemp2.setTotalTP(Ts2, Psin/psicf);
		drhodT = (Fstemp2.rhot-Fstemp1.rhot)/(2.*dT);
		// drhodh
		dh = hsin*0.001;
		hs1 = hsin-dh;
		hs2 = hsin+dh;
		Fstemp1.setTotal_hP(hs1/BTUcf, Psin/psicf);
		Fstemp2.setTotal_hP(hs2/BTUcf, Psin/psicf);
		drhodh = (Fstemp2.rhot-Fstemp1.rhot)/(2.*dh);
		// drhodphi
		/*
		Fstemp1.copyFlow("Fl_Otemp");
		Fstemp2.copyFlow("Fl_Otemp");
		dphi = 0.001*FAR0/FARstoic; // 0.1; 0.01; 0.001 give close results, starts to diverge at 0.0001	
		Fu_I.Wfuel = Wair*FARstoic*dphi;
		Fstemp1.burn("Fu_I", 1.);
		Fstemp1.setTotal_hP(hsin/BTUcf, Psin/psicf);
		Fu_I.Wfuel = 2.*Wair*FARstoic*dphi;
		Fstemp2.burn("Fu_I", 1.);
		Fstemp2.setTotal_hP(hsin/BTUcf, Psin/psicf);
		drhodphi = (-3.*Fl_Otemp.rhot+4.*Fstemp1.rhot-Fstemp2.rhot)/(2.*dphi);
		*/
		drhodphi = 0.;
		// Test
		cout << endl;
		cout << "drhodP = " << drhodP << "  ";
		cout << "drhodh = " << drhodh << "  ";
		cout << "drhodphi = " << drhodphi << endl;
		
		// Im
		term1 = -rhoin*Vin*(Vin-Vfx)*dWdxW;   
		term2 = -0.5*rhoin*(Vin**2)*Cf*Cw/(Ain*dx);
		Im = term1+term2;         
		
		// Test
		cout << endl;
		cout << "Im term1 = " << term1 << "  ";
		cout << "Im term2 = " << term2 << "  ";
		cout << "Im = " << Im << endl;
		
		// Ie
		Fl_Otemp.setTotal_hP(ht/BTUcf, Psin/psicf);
		Fstemp2.copyFlow("Fl_Otemp");
		Fu_I.Wfuel = Wair*FAR0*calcdetamdx(x+0.5*dx, dx)*dx;
		Fstemp2.burn("Fu_I", 1.);
		term1 = -(Fstemp2.ht*BTUcf-ht)/dx;
		
		qw = 0.5*rhoin*Vin*Cp*Cf*(Tw-Taw)/(Pr**(1./3.));
		term2 = qw*Cw/(Win*dx);
		
		Ie = term1+term2;
		
		// Test
		cout << endl;
		cout << "Ie term1 = " << term1 << "  ";
		cout << "Ie term2 = " << term2 << "  ";
		cout << "Ie = " << Ie << endl;
		
		// D
		term1 = 1.-(Vin**2)*drhodP;
		term2 = 1.-((Vin**2)*drhodh)/rhoin;
		term3 = ((Vin**4)*drhodP*drhodh)/rhoin;
		D = term1*term2-term3;
		// RHS1
		term1 = (rhoin*(Vin**2)*dAdx)/Ain;
		term2 = (Vin**2)*drhodphi*dphidx;
		term3 = -(rhoin*(Vin**2)*dWdxW);
		RHS1 = term1+term2+term3+Im;
		// RHS2
		term1 = ((Vin**2)*dAdx)/Ain;
		term2 = (Vin**2)*drhodphi*dphidx/rhoin;
		term3 = -(Vin**2)*dWdxW;
		RHS2 = term1+term2+term3+Ie;
		// E
		term1 = (Vin**2)*drhodP*RHS1/rhoin;
		term2 = (1.-(Vin**2)*drhodP)*RHS2;
		E = term1+term2;
		// dhs/dx
		dhsdx = E/D;
		// D and E will be different
		// E
		term1 = (Vin**2)*drhodh*dhsdx;
		E = term1+RHS1;
		// D
		D = 1.-(Vin**2)*drhodP;
		// dPs/dx
		dPsdx = E/D;
		// dht/dx
		dhtdx = Ie;
		/*
		// Calculate dPs/dx
		dPsdx = 0.5*rhoin*(Vin**2)*Cf*(89./Dw)/4633.056;
		*/
		
		// Test
		cout << endl;
		cout << "dht/dx = " << dhtdx << endl;
		cout << "dhs/dx = " << dhsdx << endl;
		cout << "dPs/dx = " << dPsdx << endl;
	}
	//-----------------------------------------------------------------------------------------	
	// Isolator Attached Zone - 4th RK
	//-----------------------------------------------------------------------------------------	
	void RKisoatt() {
		cout << endl;
		cout << endl;
		cout << "*******************ISOLATOR ATTACHED ZONE********************" << endl;
		cout << endl;		
		for (i=0; i<Niatt; i++) {
			Ptintemp = Ptin;
			htintemp = htin;
			// Position
			x = x2+dxiatt*i;
			
			// Test
			cout << endl;
			cout << "*******************Position********************" << endl;
			cout << "x = " << x << endl;
			
			//-----------------------------------------------------------------------------------------
			// Step 1
			cout << endl;
			cout << "-----------------Step 1-------------------------------------------" << endl;
			calcDeliatt(Ptintemp, htintemp, x, dxiatt);
			k1 = dPtdx;
			l1 = dhtdx;
			//-----------------------------------------------------------------------------------------
			// Step 2
			cout << endl;
			cout << "-----------------Step 2-------------------------------------------" << endl;
			calcDeliatt(Ptintemp+0.5*k1*dxiatt, htintemp+0.5*l1*dxiatt, x+0.5*dxiatt, dxiatt);
			k2 = dPtdx;
			l2 = dhtdx;
			//-----------------------------------------------------------------------------------------
			// Step 3
			cout << endl;
			cout << "-----------------Step 3-------------------------------------------" << endl;
			calcDeliatt(Ptintemp+0.5*k2*dxiatt, htintemp+0.5*l2*dxiatt, x+0.5*dxiatt, dxiatt);
			k3 = dPtdx;
			l3 = dhtdx;
			//-----------------------------------------------------------------------------------------
			// Step 4
			cout << endl;
			cout << "-----------------Step 4------------------------------------------" << endl;
			calcDeliatt(Ptintemp+k3*dxiatt, htintemp+l3*dxiatt, x+dxiatt, dxiatt);
			k4 = dPtdx;
			l4 = dhtdx;
			cout << endl;
			cout << "-----------------End Step------------------------------------------" << endl;
			//-----------------------------------------------------------------------------------------
			dPtdx = (k1+2.*k2+2.*k3+k4)/6.;
			dhtdx = (l1+2.*l2+2.*l3+l4)/6.;
			//-----------------------------------------------------------------------------------------
			// Test
			cout << endl;
			cout << "dPtdx = " << dPtdx << endl;
			cout << "dhtdx = " << dhtdx << endl;
			//-----------------------------------------------------------------------------------------	
			// Setup Fl_O with new Ps and Ts
			//-----------------------------------------------------------------------------------------	
			Ptout = Ptintemp+dPtdx*dxiatt;
			htout = htintemp+dhtdx*dxiatt;
			// Set ht, Pt
			Fl_O.setTotal_hP(htout, Ptout);
			Fl_O.Aphy = A;
			Fl_O.superOrSub = "SUPERSONIC";
			
			Psout = Fl_O.Ps;
			Tsout = Fl_O.Ts;
			Vout = Fl_O.V;
			
			// Test
			cout << endl;
			cout << "Psout = " << Psout << endl;
			cout << "Tsout = " << Tsout << endl;
			cout << "Vout = " << Vout << endl;
			cout << "MNout = " << Fl_O.MN << endl;
			cout << endl;
			cout << "*******************Next Iteration********************" << endl;
			
			// Text output
			textOutputUpdate(x, dxiatt);
			//-----------------------------------------------------------------------------------------	
			// Prepare Psin, Tsin for the next iteration
			//-----------------------------------------------------------------------------------------
			Ptin = Ptout;
			htin = htout;
		}
		Psin = Psout; // For RKisosep calculation start point 
	}
	//-----------------------------------------------------------------------------------------	
	// Isolator Separated Zone - 4th RK
	//-----------------------------------------------------------------------------------------	
	void RKisosep() {
		cout << endl;
		cout << endl;
		cout << "*******************ISOLATOR SEPARATION ZONE********************" << endl;
		cout << endl;
		for (i=0; i<Nisep; i++) {
			Ptintemp = Ptin;
			htintemp = htin;
			Psintemp = Psin;
			// Position
			x = xu+dxisep*i;
			
			// Test
			cout << endl;
			cout << "*******************Position********************" << endl;
			cout << "x = " << x << endl;
			
			//-----------------------------------------------------------------------------------------
			// Step 1
			cout << endl;
			cout << "-----------------Step 1-------------------------------------------" << endl;
			calcDelisep(Ptintemp, htintemp, Psintemp, x, dxisep);
			k1 = dPtdx;
			l1 = dhtdx;
			m1 = dPsdx;
			//-----------------------------------------------------------------------------------------
			// Step 2
			cout << endl;
			cout << "-----------------Step 2-------------------------------------------" << endl;
			calcDelisep(Ptintemp+0.5*k1*dxisep, htintemp+0.5*l1*dxisep, Psintemp+0.5*m1*dxisep, x+0.5*dxisep, dxisep);
			k2 = dPtdx;
			l2 = dhtdx;
			m2 = dPsdx;
			//-----------------------------------------------------------------------------------------
			// Step 3
			cout << endl;
			cout << "-----------------Step 3-------------------------------------------" << endl;
			calcDelisep(Ptintemp+0.5*k2*dxisep, htintemp+0.5*l2*dxisep, Psintemp+0.5*m2*dxisep, x+0.5*dxisep, dxisep);
			k3 = dPtdx;
			l3 = dhtdx;
			m3 = dPsdx;
			//-----------------------------------------------------------------------------------------
			// Step 4
			cout << endl;
			cout << "-----------------Step 4------------------------------------------" << endl;
			calcDelisep(Ptintemp+k3*dxisep, htintemp+l3*dxisep, Psintemp+m3*dxisep, x+dxisep, dxisep);
			k4 = dPtdx;
			l4 = dhtdx;
			m4 = dPsdx;
			cout << endl;
			cout << "-----------------End Step------------------------------------------" << endl;
			//-----------------------------------------------------------------------------------------
			dPtdx = (k1+2.*k2+2.*k3+k4)/6.;
			dhtdx = (l1+2.*l2+2.*l3+l4)/6.;
			dPsdx = (m1+2.*m2+2.*m3+m4)/6.;
			//-----------------------------------------------------------------------------------------
			// Test
			cout << endl;
			cout << "dPtdx = " << dPtdx << endl;
			cout << "dhtdx = " << dhtdx << endl;
			cout << "dPsdx = " << dPsdx << endl;
			//-----------------------------------------------------------------------------------------	
			// Setup Fl_O with new Ps and Ts
			//-----------------------------------------------------------------------------------------	
			Ptout = Ptintemp+dPtdx*dxisep;
			htout = htintemp+dhtdx*dxisep;
			Psout = Psintemp+dPsdx*dxisep;
			// Set ht, Pt
			Fl_O.setTotal_hP(htout, Ptout);
			Fl_O.Ps = Psout;
			
			Tsout = Fl_O.Ts;
			Vout = Fl_O.V;
			
			// Test
			cout << endl;
			cout << "Psout = " << Psout << endl;
			cout << "Tsout = " << Tsout << endl;
			cout << "Vout = " << Vout << endl;
			cout << "MNout = " << Fl_O.MN << endl;
			cout << endl;
			cout << "*******************Next Iteration********************" << endl;
			
			// Text output
			textOutputUpdate(x, dxisep);
			//-----------------------------------------------------------------------------------------	
			// Prepare for the next iteration
			//-----------------------------------------------------------------------------------------
			Ptin = Ptout;
			htin = htout;
			Psin = Psout;
		}
	}
	//-----------------------------------------------------------------------------------------	
	// Combustor - 4th RK
	//-----------------------------------------------------------------------------------------	
	void RKc() {
		cout << endl;
		cout << endl;
		cout << "*******************COMBUSTOR********************" << endl;
		cout << endl;
		flag = 0; 
		flag2 = 0;
		//MN[0] = Fl_O.MN;
		for (i=0; i<Nc; i++) {
			Psintemp = Psin;
			htintemp = htin;
			hsintemp = hsin;
			// Position
			x = x3+dxc*i;
			
			// Test
			cout << endl;
			cout << "*******************Position********************" << endl;
			cout << "x = " << x << endl;
			
			//-----------------------------------------------------------------------------------------
			// Step 1
			cout << endl;
			cout << "-----------------Step 1-------------------------------------------" << endl;
			calcDelc(Psintemp, htintemp, hsintemp, x, dxc, 0., flag, flag2);
			k1 = dPsdx;
			l1 = dhtdx;
			m1 = dhsdx;
			//-----------------------------------------------------------------------------------------
			// Step 2
			cout << endl;
			cout << "-----------------Step 2-------------------------------------------" << endl;
			calcDelc(Psintemp+0.5*k1*dxc, htintemp+0.5*l1*dxc, hsintemp+0.5*m1*dxc, x+0.5*dxc, dxc, 0.5, flag, flag2);
			k2 = dPsdx;
			l2 = dhtdx;
			m2 = dhsdx;
			//-----------------------------------------------------------------------------------------
			// Step 3
			cout << endl;
			cout << "-----------------Step 3-------------------------------------------" << endl;
			calcDelc(Psintemp+0.5*k2*dxc, htintemp+0.5*l2*dxc, hsintemp+0.5*m2*dxc, x+0.5*dxc, dxc, 0.5, flag, flag2);
			k3 = dPsdx;
			l3 = dhtdx;
			m3 = dhsdx;
			//-----------------------------------------------------------------------------------------
			// Step 4
			cout << endl;
			cout << "-----------------Step 4------------------------------------------" << endl;
			calcDelc(Psintemp+k3*dxc, htintemp+l3*dxc, hsintemp+m3*dxc, x+dxc, dxc, 1., flag, flag2);
			k4 = dPsdx;
			l4 = dhtdx;
			m4 = dhsdx;
			cout << endl;
			cout << "-----------------End Step------------------------------------------" << endl;
			//-----------------------------------------------------------------------------------------
			dPsdx = (k1+2.*k2+2.*k3+k4)/6.;
			dhtdx = (l1+2.*l2+2.*l3+l4)/6.;
			dhsdx = (m1+2.*m2+2.*m3+m4)/6.;
			//-----------------------------------------------------------------------------------------
			// Test
			cout << endl;
			cout << "dPsdx = " << dPsdx << endl;
			cout << "dhtdx = " << dhtdx << endl;
			cout << "dhsdx = " << dhsdx << endl;
			//-----------------------------------------------------------------------------------------	
			// Setup Fl_O with new Ps and Ts
			//-----------------------------------------------------------------------------------------	
			Psout = Psintemp+dPsdx*dxc;
			htout = htintemp+dhtdx*dxc;
			hsout = hsintemp+dhsdx*dxc;
			// Burn
			detamdx = calcdetamdx(x+0.5*dxc, dxc); //0.8*5./(L*(1.+4.*((x+dx)/L))**2);
			Fu_I.Wfuel = Wair*FAR0*detamdx*dxc;
			Fl_O.burn("Fu_I", 1.);
			// Set Ps, ht, hs
			
			Vout = (2.*(htout-hsout))**0.5;
			Fl_O.setTotal_hP(hsout/BTUcf, Psout/psicf);
			Tsout = Fl_O.Tt;
			gamaout = Fl_O.gamt;
			Rout = Fl_O.Rt*BTUcf;
			sonicSpeed = (gamaout*Rout*Tsout)**0.5;
			MNout = Vout/sonicSpeed;
			
			// Test
			cout << endl;
			cout << "Psout = " << Psout << endl;
			cout << "Tsout = " << Tsout << endl;
			cout << "Vout = " << Vout << endl;
			cout << "MNout = " << MNout << endl;
			cout << "Flag = " << flag << endl;
			cout << "Flag2 = " << flag2 << endl;
			cout << endl;
			cout << "*******************Next Iteration********************" << endl;
			cout << endl;
			// Text output
			textOutputUpdate(x, dxc);
			//-----------------------------------------------------------------------------------------	
			// Prepare for the next iteration
			//-----------------------------------------------------------------------------------------
			Psin = Psout;
			htin = htout;
			hsin = hsout;
		}
	}
	//-----------------------------------------------------------------------------------------	
	// Main Program
	//-----------------------------------------------------------------------------------------	
	initiate();
	textinitiate();
	/*
	xu = Li;//7.086614; //inch
	dxiatt = (xu-x2)/Niatt;
	dxisep = (x3-xu)/Nisep;
	RKisoatt();
	RKisosep();
	*/
	Vfx = calcVfx();
	Lmix = calcLmix();
	RKc();
	Fl_O.setTotal_hsPsV(hsout/BTUcf, Psout/psicf, Vout);
	//Fl_O.Aphy = A/in2cf;
	//Fl_O.superOrSub = "SUPERSONIC";
  }
  //------------------------------------------------------------
  // register the appropriate errors at build time
  //------------------------------------------------------------
  void VCinit()
  {
    ESOregCreate( 1023901, 8, "", TRUE, FALSE, TRUE ); // provisional
    ESOregCreate( 1093901, 8, "", TRUE, FALSE, TRUE ); // provisional
  }
}
#endif