/*******************************************************************************
Copyright 2003. The U.S. Government, as Represented by the Administrator of
the National Aeronautics and Space Administration (NASA). All rights reserved.
Includes content licensed from the U.S. Government, National Aeronautics and
Space Administration under United States Copyright Registration Numbers
V3503D364 and V3482D344.
Copyright 2008-2015 NPSS Consortium, www.NPSSConsortium.org/AllRightsReserved
*******************************************************************************/

/*******************************************************************************
NPSS software and related documentation is export controlled with an Export
Control Classification Number(ECCN) of 9D991, controlled for Anti-Terrorism
reasons, under U.S. Export Administration Regulations 15 CFR 730-774. It may
not be transferred to a country checked under anti-terrorism on the Commerce
Country Chart structure or to foreign nationals of those countries in the U.S.
or abroad without first obtaining a license from the Bureau of Industry and
Security, United States Department of Commerce. Violations are punishable by
fine, imprisonment, or both.
*******************************************************************************/
//
// For further information contact support@npssconsortium.org
//
// CONVERSION FACTORS
//
// 1 BTU/lbm -- 25037. (ft/sec)^2
// 1 psia -- 4633.056 (lbm*ft/sec^2)/ft^2 
// 1 BTU -- 25037. lbm*(ft/sec)^2
// 1 ft -- 12. inch
//
#ifndef __SJBurner1D__
#define __SJBurner1D__

#include <InterpIncludes.ncp>

class SJBurner1D extends Element {

  //------------------------------------------------------------
  //     ******* SETUP VARIABLES ********
  //------------------------------------------------------------
  // Inputs
  //------------------------------------------------------------
  // Isolator
  real Li {
	  value = 10.;	IOstatus = INPUT;	units = INCH;
	  description = "Isolator length";
  }
  int Niatt {
	  value = 100;	IOstatus = INPUT;	units = NONE;
	  description = "Number of points";
  }
  int Nisep {
	  value = 100;	IOstatus = INPUT;	units = NONE;
	  description = "Number of points";
  }
  // Combustor
    real Lc {
	  value = 10.;	IOstatus = INPUT;	units = INCH;
	  description = "Combustor length";
  }
  int Nc {
	  value = 100;	IOstatus = INPUT;	units = NONE;
	  description = "Number of points";
  }
  // Ajet3
  real Ajet3 {
	  value = 10.;	IOstatus = INPUT;	units = INCH2;
	  description = "Fuel Jet Area at Station 3";
  }
  real xinj {
	  value = 0.;	IOstatus = INPUT;	units = INCH;
	  description = "Injector position";
  }
  // For combustor diverging area
  real a1 {
	  value = 1.;	IOstatus = INPUT;	units = INCH2;
	  description = "First Coeff";
  }
  real a2 {
	  value = 1.;	IOstatus = INPUT;	units = INCH2;
	  description = "Second Coeff";
  } 
  real xa2 {
	  value = 1.;	IOstatus = INPUT;	units = INCH;
	  description = "a2 position";
  }
  real a3 {
	  value = 1.;	IOstatus = INPUT;	units = INCH2;
	  description = "Third Coeff";
  } 
  // Wall Temperature
  real Tw {
	  value = 1080.;	IOstatus = INPUT;	units = RANKINE;
	  description = "Wall temperature";
  }
  real Pr {
	  value = 0.72;		IOstatus = INPUT;	units = NONE;
	  description = "Prandtl number";
  }
  // FAR stoic
  real FARstoic {
	  value = 0.0674;	IOstatus = INPUT;	units = NONE;
	  description = "Stoichiometric FAR";
  }
  real phi0 {
	  value = 0.0291;	IOstatus = INPUT;	units = NONE;
	  description = "Initial equivalence ratio";
  }
  //------------------------------------------------------------
  // Outputs
  //------------------------------------------------------------
  real Vout {
	  value = 0;	IOstatus = OUTPUT; units = FT_PER_SEC;
	  description = "Velocity";
  }
  real Psout {
	  value = 0;	IOstatus = OUTPUT; units = PSIA;
	  description = "Static Pressure";
  }
  real Tsout {
	  value = 0;	IOstatus = OUTPUT; units = RANKINE;
	  description = "Static Temperature";
  }
  real MNout {
	  value = 0;	IOstatus = OUTPUT; units = NONE;
	  description = "Mach Number";
  }
  //------------------------------------------------------------
  //   ******* OPTION VARIABLE SETUP *******
  //------------------------------------------------------------
	
  //------------------------------------------------------------
  // ****** SETUP PORTS, FLOW STATIONS, SOCKETS, TABLES ********
  //------------------------------------------------------------
  
  // FLUID PORTS
  FluidInputPort Fl_I {
    description = "Incoming flow";
  }

  FluidOutputPort Fl_O {
    description = "Exiting flow";
  }
  
  // FUEL PORTS
  FuelInputPort Fu_I {
    description = "Incoming fuel flow";
  }
  // BLEED PORTS
  
  // THERMAL PORTS
  
  // MECHANICAL PORTS
  
  // FLOW STATIONS 
  FlowStation Fl_Otemp;
  Fl_Otemp.setOption("switchTransport", "EQUIL");
  FlowStation Fstemp1;
  Fstemp1.setOption("switchTransport", "EQUIL");
  FlowStation Fstemp2;
  Fstemp2.setOption("switchTransport", "EQUIL");
  // SOCKETS
  
  // TABLES
  
  // DATA PORTS

  //------------------------------------------------------------
  // ******* INTERNAL SOLVER SETUP *******
  //------------------------------------------------------------
  
  //------------------------------------------------------------
  //  ******  ADD SOLVER INDEPENDENTS & DEPENDENTS  ******
  //------------------------------------------------------------
  
  //------------------------------------------------------------
  // ******* VARIABLE CHANGED METHODOLOGY *******
  //------------------------------------------------------------
  
  //------------------------------------------------------------
  //   ******* PERFORM ENGINEERING CALCULATIONS *******
  //------------------------------------------------------------
  
  void calculate() {
	// Unit conversion: All parameters from flow stations are converted into normal standard, 
	// then converted back into flow station standard if needed when inputed into flow station functions
	// ONLY L and x are allowed in inch
	real intoft = 1./12.;
	real in2cf = 1./144.;
	real mtoin = 39.3701;
	real m2toin2 = 39.3701**2;
	real BTUcf = 25037.;
	real psicf = 4633.056;
	real KtoR = 1.8;
	real Patopsi = 0.000145038;
	real pi = 3.1416;
	real e = 2.71828;
	//Fl_I.Aphy = a1-Ajet3;
	
	//------------------------------------------------------------
    // Text Output Function
    //------------------------------------------------------------
	OutFileStream os_EngResultsRow {
	// Name of the output file that is created by this out stream
	filename = "cout"; // sent results to the command prompt
	//filename = "EngResults.txt";
	}
	// Create the Case Row Viewer named EngResultsRow
	DataViewer CaseRowViewer EngResultsRow {

		// Specify the OutFileStream object to use for this viewer
		outStreamHandle = "os_EngResultsRow";
		
		// Set the default number format for real and scientific notation
		defRealFormat = "????????.???????";
		defSNFormat =   "??.???????E?????";
		
		// List the variables that you want to print to the output file
		variableList = {
				"MNtext : ??.??????? = MN",
				"Vtext : ?????.??????? = V",
				"CPtext : ?????.??????? = CP",
				"httext : ?????????.??????? = ht/ht2",
				"Pstext : ?????.??????? = Ps/Ps2",
				"Tstext : ?????.??????? = Ts/Ts2",
				"Aphytext : ?????.??????? = Ac/A2",
				"Artext : ?????.??????? = Ac/Awall",
				"O2text : ??.???????? = O2",
				"H2Otext : ??.???????? = H2O",
				"CO2text : ??.???????? = CO2",
				"N2text : ??.???????? = N2",
				"etamtext : ??.???????? = etam"
			}
			
		titleBody = "";  // Title to display (if desired)
		titleVars = {};
		
		// Print the Case in the file header
		caseHeaderBody = "x ???.???????"; // Case header title to display
		caseHeaderVars = {"xtext"}; // Actual case number
		
		pageWidth = 10000;
		pageHeight = 10000.;
	}
	real xtext; 
	real MNtext; 
	real Vtext; 
	real CPtext; 
	real httext; 
	real Pstext;
	real Tstext; 
	real Aphytext;
	real Artext;
	real O2text;
	real H2Otext;
	real CO2text;
	real N2text;
	real etamtext;
	void textinitiate() {
		xtext = 0.;
		MNtext = MNin; 
		Vtext = Vin; 
		CPtext = (Psin-Ps0)/q0;
		httext = htin/(Fl_I.ht*BTUcf);
		Pstext = Psin/(Fl_I.Ps*psicf);
		Tstext = Tsin/Fl_I.Ts;
		Aphytext = Ain/(Fl_I.Aphy*in2cf);
		Artext = Ain/calcAwall(0.);
		O2text = Fl_I.getTotalComp("O2");
		H2Otext = Fl_I.getTotalComp("H2O");
		CO2text = Fl_I.getTotalComp("CO2");
		N2text = Fl_I.getTotalComp("N2");
		etamtext = calcetam(0.);
				
		os_EngResultsRow.filename = "EngResults.txt";
		EngResultsRow.isActive = TRUE;
		EngResultsRow.update();
	}
	void textOutputUpdate(real x, real dx) {
		xtext = x+dx;
	  	MNtext = MNout; 
		Vtext = Vout; 
		CPtext = (Psout-Ps0)/q0;
		httext = htout/(Fl_I.ht*BTUcf);
		Pstext = Psout/(Fl_I.Ps*psicf);
		Tstext = Tsout/Fl_I.Ts;
		Aphytext = A/(Fl_I.Aphy*in2cf);
		Artext = A/calcAwall(xtext);
		O2text = Fl_O.getTotalComp("O2");
		H2Otext = Fl_O.getTotalComp("H2O");
		CO2text = Fl_O.getTotalComp("CO2");
		N2text = Fl_O.getTotalComp("N2");
		etamtext = calcetam(xtext);
		
		os_EngResultsRow.filename = "EngResults.txt";
		EngResultsRow.isActive = TRUE;
		EngResultsRow.update();
	}
	//-----------------------------------------------------------------------------------------	
	// Initiate Function
	//-----------------------------------------------------------------------------------------
	real Ptin = Fl_I.Pt*psicf;
	real Psin = Fl_I.Ps*psicf;
	real htin = Fl_I.ht*BTUcf;
	real hsin = Fl_I.hs*BTUcf; // BTU/lbm to (f/s)^2
	real Ttin = Fl_I.Tt;
	real Tsin = Fl_I.Ts;
	real Vin = Fl_I.V;
	real MNin = Fl_I.MN;
	real Ain = Fl_I.Aphy*in2cf; // Ain in ft2
	real Win = Fl_I.W;
	real rhoin = Fl_I.rhos;
	real R = Fl_I.Rs*BTUcf; // BTU/lbm.R to (f/s)^2/R
	real Cp = Fl_I.Cps*BTUcf;
	real gama = Fl_I.gams;
	real Rein;
	real muin;
	real Wair;
	real FAR0;
	
	real MN0 = 7.5;
	real Ts0 = 100.*KtoR;
	real Ps0 = 460*Patopsi*psicf;
	real gama0 = 1.67;
	real q0 = 0.5*gama0*Ps0*MN0**2;
	void initiate() {
		// Reset Win
		Vin = Fl_I.V;
		rhoin = Fl_I.rhos;
		Ain = calcAwall(0.);
		if (xinj == 0.) {
			Ain = Ain-Ajet3*in2cf;
		}
		Fl_I.W = Ain*rhoin*Vin;
		
		Ptin = Fl_I.Pt*psicf;
		Psin = Fl_I.Ps*psicf;
		htin = Fl_I.ht*BTUcf;
		hsin = Fl_I.hs*BTUcf; // BTU/lbm to (f/s)^2
		Ttin = Fl_I.Tt;
		Tsin = Fl_I.Ts;
		Win = Fl_I.W;
		R = Fl_I.Rs*BTUcf; // BTU/lbm.R to (f/s)^2/R
		Cp = Fl_I.Cps*BTUcf;
		gama = Fl_I.gams;
		MNin = Fl_I.MN;
		
		FAR0 = phi0*FARstoic;
		Wair = Fl_I.Wa;
		
		Fl_O.copyFlowStatic("Fl_I");
	}
	//-----------------------------------------------------------------------------------------	
	// Components Calculation Functions
	//-----------------------------------------------------------------------------------------
	real term1; real term2; real term3; real term4;
	real MWf = 2.;// Hydrogen fuel
	real calcVfx() {
		// Assume fuel jet at the same temperature as the wall
		// Assume MNjet = 1
		// Set full flow condition after isolator
		return (Fl_O.gams*(Fl_O.Rs*BTUcf*Fl_O.MW/MWf)*Tw)**0.5;
	}
	//-----------------------------------------------------------------------------------------
	real Lmix;
	real K = 390.;
	real Mc;
	real fMc;
	real Df = (4.*Ajet3/pi)**0.5;
	real rhof = 0.003;//0.00512; //H2 lbm/ft3 at 300K, only needed for Boyce// 0.004509; 0.003;
	real aa;
	real af;
	
	real calcLmix() {
		// Hydrogen parallel strut injection
		/*
		af = Vfx; // as Mjet = 1
		aa = (Fl_O.gams*Fl_O.Rs*BTUcf*Fl_O.Ts)**0.5;
		Mc = (Vfx-Fl_O.V)/(aa+af);
		term1 = 3.*(Mc**2);
		term2 = e**(-term1);
		fMc = 0.25+0.75*term2;	
		return ((Df*K*((rhof*Vfx)/(Fl_O.rhos*Fl_O.V))**0.5)/fMc);
		*/
		// Hydrogen normal injection - Hyshot, Lmix = 60G
		
		return 60.*0.056*mtoin;//0.34*mtoin;;//60.*0.0098*mtoin;
		
	}
	//-----------------------------------------------------------------------------------------
	// Hydrogen parallel strut injection
	real alpha = 1.06;
	real k = 3.69639;
	real d = 0.80586;
	// Linear fit
	real lamda = 10.;
	real etab = 1.;
	
	real calcetam(real x) {
		x = x-xinj;
		if (x <= 0.) {
			return 0.;
		} else {			
			// Linear fit
			/*
			term1 = etab*lamda*x/(Lmix+(lamda-1.)*x);
			if (term1 < 1.) {
				return term1;
			} else {
				return 1.;
			}
			*/
			// Hydrogen parallel strut injection
			/*
			// etam = alpha*(1.-e**(-(k*x/Lmix)**d));
			// Group too many operations in one line will give NaN result
			term1 = (k*x)/Lmix;
			term2 = term1**d;
			term3 = e**(-term2);
			if (alpha*(1.-term3)<1.) {
				return alpha*(1.-term3);
			} else {
				return 1.;
			}
			*/
			// Hydrogen normal injection
				
			term1 = 0.179*Lmix*exp(1.72*phi0);
			term2 = 1.01+0.176*log(x/term1);
			if (term2 < 1.) {
				if (term2 < 0.) {
					return 0.;
				} else {
					return term2;
				}
			} else {
				return 1.;
			}
			
			// Normal or angular injection - Segal
			/*
			term1 = x/Lmix;
			term2 = 1./(50.+1000.*0.25);
			term3 = (term1+term2)**0.25;
			if (term3 < 1.) {
				return term3;
			} else {
				return 1.;
			}
			*/
		}
		// Isolator
		/*
		return 0.;
		*/
	}
	//-----------------------------------------------------------------------------------------
	real calcdetamdx(real x, real dx) {
		x = x-xinj;
		if (x < 0.) {
			return 0.;
		} else {
			// Linear fit
			/*
			return etab*lamda/(Lc*(1.+(lamda-1.)*(x/Lmix))**2);
			*/
			// Hydrogen parallel strut injection
			/*
			if (x == 0.) {
				return (-3.*calcetam(x)+4.*calcetam(x+dx)-calcetam(x+2.*dx))/(2.*dx);
			} else {
				if (calcetam(x) == 1.) {
					return 0.;
				} else {
					term1 = (k*x)/Lmix;
					term2 = term1**d;
					term3 = e**(-term2);
					term4 = term1**(d-1.);
					return alpha*d*(k/Lmix)*term3*term4;
				}
			}
			*/
			// Universal - Difference formula
			
			return (-3.*calcetam(x)+4.*calcetam(x+dx)-calcetam(x+2.*dx))/(2.*dx);
		}
		// Isolator
		/*
		return 0.;
		*/
	}
	//-----------------------------------------------------------------------------------------
	real calcAwall(real x) {
		if (x < x3) {
			return a1*in2cf;
		} else {
			if (x < xa2) {
				return ((a2-a1)*(x-x3)/(xa2-x3)+a1)*in2cf;
			} else {
				return ((a3-a2)*(x-xa2)/(x4-xa2)+a2)*in2cf;
			}
		}
	}
	//-----------------------------------------------------------------------------------------
	real calcdAwalldx(real x) {
		if (x < x3) {
			return 0.;
		} else {
			if (x < xa2) {
				return ((a2-a1)/(xa2-x3))*in2cf;
			} else {
				return ((a3-a2)/(x4-xa2))*in2cf;
			}
		}
	}
	//-----------------------------------------------------------------------------------------	
	// Calculate dPs/dx, dhs/dx, dht/dx
	//-----------------------------------------------------------------------------------------
	real Awall; real dAwalldx;
	real Ajet; real dAjetdx;
	real A; real dAdx;
	
	real Dw;
	real Vfx;
	real etam;
	real detamdx;
	real dWdxW;
	real dphidx;
	real Im;
	real Ie;
	real D; real E; real RHS1; real RHS2;
	
	real qw;
	real Cw;
	real Taw;

	real drhodP;
	real dP; real Ps1; real Ps2; real Pt1; real Pt2;
	real drhodh;
	real dh; real hs1; real hs2; real Vin1; real Vin2;
	real drhodphi;
	real dphi;
	
	real dhtdx;
	real dhsdx;
	real dPsdx;
	// For calculating Cf
	real Cf;
	real _R = 111.*KtoR;
	real Retrans;
	real Tref;
	real Reref;
	real rhoref;
	real muref;
	// For calculating Cf
	real _T;
	real _C;
	real Re;
	//-----------------------------------------------------------------------------------------	
	// Isolator - Attached Zone
	//-----------------------------------------------------------------------------------------
	void calcDeliatt(real Ps, real ht, real hs, real x, real dx) {
		
		// Test
		cout << endl;
		cout << "INPUT:  ";
		cout << "Psin = " << Ps << "  ";
		cout << "hsin = " << hs << "  ";
		cout << "htin = " << ht << endl;
		
		// etam
		etam = 0.;
		//detam/dx
		detamdx = 0.;
		// Awall(x)
		Awall = calcAwall(x); 
		// dAwall/dx
		dAwalldx = calcdAwalldx(x);
		// A
		A = Awall;  
		// dA/dx
		dAdx = dAwalldx;
		
		Fl_Otemp.copyFlow("Fl_O");
		// Set flow properties
		Fl_Otemp.setTotal_hP(hs/BTUcf, Ps/psicf);
		// Flow properties
		Psin = Fl_Otemp.Pt*psicf;
		hsin = Fl_Otemp.ht*BTUcf;
		Tsin = Fl_Otemp.Tt;
		Vin = (2.*(ht-hs))**0.5;
		Win = Fl_Otemp.W;
		Ain = A;
		rhoin = Fl_Otemp.rhot;
		R = Fl_Otemp.Rt*BTUcf;
		Cp = Fl_Otemp.Cpt*BTUcf;
		
		// Test
		cout << endl;
		cout << "hsin = " << hsin << "  ";
		cout << "Psin = " << Psin << "  ";
		cout << "Tsin = " << Tsin << "  ";
		cout << "Vin = " << Vin << "  ";
		cout << "Ain = " << Ain << "  ";
		cout << "rhoin = " << rhoin << "  ";
		cout << "Wfuel = " << Fl_Otemp.Wf << "  ";
		cout << "Win = " << Win << "  ";
		cout << "mu = " << Fl_Otemp.mut << endl;
		
		// Dw
		Dw = (4.*Awall/pi)**0.5;
		// Cw
		Cw = pi*Dw*dx*intoft;  // Dw in ft, dx in inch --> ft
		// Reynold number
		muin = Fl_Otemp.mut;
		Rein = rhoin*Vin*Dw/muin;
		// Transient Reynold
		term1 = 1.209*(10**(-4))*(MNin**2.641);
		term2 = 6.421*(e**term1);
		Retrans = 10**term2;
		// Cf and qw
		MNin = Vin/((gama*R*Tsin)**0.5);
		if (Rein >= Retrans) { 
			// Turbulent 
			Tref = 0.5*Tsin+0.5*Tw+0.5*0.16*(Pr**(1./3.))*(gama-1.)*Tsin*(MNin**2.);
			rhoref = rhoin*Tsin/Tref;
			muref = muin*((Tref/Tsin)**1.5)*((Tsin+_R)/(Tref+_R));
			Reref = rhoref*Vin*Dw/muref;
			Cf = 0.02296/(Reref**0.139);
			
			Taw = Tsin*(1.+Pr**(1./3.)*(0.5*(gama-1.)*(MNin**2.)));
			qw = 0.5*rhoin*Vin*Cp*Cf*(Tw-Taw)/(Pr**(1./3.));
		} else {
			// Laminar
			Tref = 0.45*Tsin+0.55*Tw+0.5*0.16*(Pr**(1./2.))*(gama-1.)*Tsin*(MNin**2.);
			rhoref = rhoin*Tsin/Tref;
			muref = muin*((Tref/Tsin)**1.5)*((Tsin+_R)/(Tref+_R));
			Reref = rhoref*Vin*Dw/muref;
			Cf = 0.664/(Reref**0.5);
			
			Taw = Tsin*(1.+Pr**(1./2.)*(0.5*(gama-1.)*(MNin**2.)));
			qw = 0.5*rhoin*Vin*Cp*Cf*(Tw-Taw)/(Pr**(2./3.));
		}
		
		// Test
		cout << endl;
		cout << "Rein = " << Rein << "  ";
		cout << "Retrans = " << Retrans << "  ";
		cout << "Cf = " << Cf << endl;
		
		// drhodP
		Fstemp1.copyFlow("Fl_Otemp");
		Fstemp2.copyFlow("Fl_Otemp");
		// Same phi --> same ht, same hs --> same Vin
		dP = Psin*0.001;
		Ps1 = Psin-dP;
		Ps2 = Psin+dP;
		Fstemp1.setTotal_hP(hsin/BTUcf, Ps1/psicf);
		Fstemp2.setTotal_hP(hsin/BTUcf, Ps2/psicf);
		drhodP = (Fstemp2.rhot-Fstemp1.rhot)/(2.*dP);
		// drhodh
		dh = hsin*0.001;
		hs1 = hsin-dh;
		hs2 = hsin+dh;
		Fstemp1.setTotal_hP(hs1/BTUcf, Psin/psicf);
		Fstemp2.setTotal_hP(hs2/BTUcf, Psin/psicf);
		drhodh = (Fstemp2.rhot-Fstemp1.rhot)/(2.*dh);
		// drhodphi
		drhodphi = 0.;
		// Test
		cout << endl;
		cout << "drhodP = " << drhodP << "  ";
		cout << "drhodh = " << drhodh << "  ";
		cout << "drhodphi = " << drhodphi << endl;
		
		// dW/(W*dx)
		dWdxW = (FAR0*detamdx)/(1.+FAR0*etam);
		// Im
		term1 = -rhoin*Vin*(Vin-Vfx)*dWdxW;   
		term2 = -0.5*rhoin*(Vin**2)*Cf*Cw/(Ain*dx);
		Im = term1+term2;         
		
		// Test
		cout << endl;
		cout << "Im term1 = " << term1 << "  ";
		cout << "Im term2 = " << term2 << "  ";
		cout << "Im = " << Im << endl;
		
		// Ie
		term1 = 0.;		
		term2 = qw*Cw/(Win*dx);
		Ie = term1+term2;
		
		// Test
		cout << endl;
		cout << "Ie term1 = " << term1 << "  ";
		cout << "Ie term2 = " << term2 << "  ";
		cout << "Ie = " << Ie << endl;
		
		// dphidx
		dphidx = (FAR0*detamdx)/FARstoic;
		// D
		term1 = 1.-(Vin**2)*drhodP;
		term2 = 1.-((Vin**2)*drhodh)/rhoin;
		term3 = ((Vin**4)*drhodP*drhodh)/rhoin;
		D = term1*term2-term3;
		// RHS1
		term1 = (rhoin*(Vin**2)*dAdx)/Ain;
		term2 = (Vin**2)*drhodphi*dphidx;
		term3 = -(rhoin*(Vin**2)*dWdxW);
		RHS1 = term1+term2+term3+Im;
		// RHS2
		term1 = ((Vin**2)*dAdx)/Ain;
		term2 = (Vin**2)*drhodphi*dphidx/rhoin;
		term3 = -(Vin**2)*dWdxW;
		RHS2 = term1+term2+term3+Ie;
		// E
		term1 = (Vin**2)*drhodP*RHS1/rhoin;
		term2 = (1.-(Vin**2)*drhodP)*RHS2;
		E = term1+term2;
		// dhs/dx
		dhsdx = E/D;
		// D and E will be different
		// E
		term1 = (Vin**2)*drhodh*dhsdx;
		E = term1+RHS1;
		// D
		D = 1.-(Vin**2)*drhodP;
		// dPs/dx
		dPsdx = E/D;
		// dht/dx
		dhtdx = Ie;
		
		// Test
		cout << endl;
		cout << "dht/dx = " << dhtdx << endl;
		cout << "dhs/dx = " << dhsdx << endl;
		cout << "dPs/dx = " << dPsdx << endl;
	}
	//-----------------------------------------------------------------------------------------	
	// Isolator - Separation zone
	//-----------------------------------------------------------------------------------------
	void calcDelisep (real Ps, real ht, real hs, real x, real dx) {
		
		// Test
		cout << endl;
		cout << "INPUT:  ";
		cout << "Psin = " << Ps << "  ";
		cout << "hsin = " << hs << "  ";
		cout << "htin = " << ht << endl;
		
		// etam
		etam = 0.;
		//detam/dx
		detamdx = 0.;
		
		Fl_Otemp.copyFlow("Fl_O");
		// Set flow properties
		Fl_Otemp.setTotal_hP(hs/BTUcf, Ps/psicf);
		// Flow properties
		Psin = Fl_Otemp.Pt*psicf;
		hsin = Fl_Otemp.ht*BTUcf;
		Tsin = Fl_Otemp.Tt;
		Vin = (2.*(ht-hs))**0.5;
		Win = Fl_Otemp.W;
		rhoin = Fl_Otemp.rhot;
		Ain = Win/(rhoin*Vin);
		R = Fl_Otemp.Rt*BTUcf;
		Cp = Fl_Otemp.Cpt*BTUcf;
		
		// Test
		cout << endl;
		cout << "hsin = " << hsin << "  ";
		cout << "Psin = " << Psin << "  ";
		cout << "Tsin = " << Tsin << "  ";
		cout << "Vin = " << Vin << "  ";
		cout << "Ain = " << Ain << "  ";
		cout << "rhoin = " << rhoin << "  ";
		cout << "Wfuel = " << Fl_Otemp.Wf << "  ";
		cout << "Win = " << Win << "  ";
		cout << "mu = " << Fl_Otemp.mut << endl;
		
		// Dw
		Dw = (4.*Awall/pi)**0.5;
		// Cw
		Cw = pi*Dw*dx*intoft;
		// Reynold number
		muin = Fl_Otemp.mut;
		Rein = rhoin*Vin*Dw/muin;
		// Transient Reynold
		term1 = 1.209*(10**(-4))*(MNin**2.641);
		term2 = 6.421*(e**term1);
		Retrans = 10**term2;
		// Cf and qw
		MNin = Vin/((gama*R*Tsin)**0.5);
		if (Rein >= Retrans) { 
			// Turbulent 
			Tref = 0.5*Tsin+0.5*Tw+0.5*0.16*(Pr**(1./3.))*(gama-1.)*Tsin*(MNin**2.);
			rhoref = rhoin*Tsin/Tref;
			muref = muin*((Tref/Tsin)**1.5)*((Tsin+_R)/(Tref+_R));
			Reref = rhoref*Vin*Dw/muref;
			Cf = 0.02296/(Reref**0.139);
			
			Taw = Tsin*(1.+Pr**(1./3.)*(0.5*(gama-1.)*(MNin**2.)));
			qw = 0.5*rhoin*Vin*Cp*Cf*(Tw-Taw)/(Pr**(1./3.));
		} else {
			// Laminar
			Tref = 0.45*Tsin+0.55*Tw+0.5*0.16*(Pr**(1./2.))*(gama-1.)*Tsin*(MNin**2.);
			rhoref = rhoin*Tsin/Tref;
			muref = muin*((Tref/Tsin)**1.5)*((Tsin+_R)/(Tref+_R));
			Reref = rhoref*Vin*Dw/muref;
			Cf = 0.664/(Reref**0.5);
			
			Taw = Tsin*(1.+Pr**(1./2.)*(0.5*(gama-1.)*(MNin**2.)));
			qw = 0.5*rhoin*Vin*Cp*Cf*(Tw-Taw)/(Pr**(2./3.));
		}
		
		// Test
		cout << endl;
		cout << "Cf = " << Cf << endl;
		
		// dW/(W*dx)
		dWdxW = (FAR0*detamdx)/(1.+FAR0*etam);
		// Im
		term1 = -rhoin*Vin*(Vin-Vfx)*dWdxW;   
		term2 = -0.5*rhoin*(Vin**2)*Cf*Cw/(Ain*dx);
		Im = term1+term2;         
		
		// Test
		cout << endl;
		cout << "Im term1 = " << term1 << "  ";
		cout << "Im term2 = " << term2 << "  ";
		cout << "Im = " << Im << endl;
		
		// Ie
		term1 = 0.;
		term2 = qw*Cw/(Win*dx);
		Ie = term1+term2;
		
		// Test
		cout << endl;
		cout << "Ie term1 = " << term1 << "  ";
		cout << "Ie term2 = " << term2 << "  ";
		cout << "Ie = " << Ie << endl;
		
		// dPs/dx
		dPsdx = 0.5*rhoin*(Vin**2)*Cf*89;
		// hds/dx
		dhsdx = dPsdx/rhoin-Im/rhoin+Ie;
		// dht/dx
		dhtdx = Ie;
		
		// Test
		cout << endl;
		cout << "dht/dx = " << dhtdx << endl;
		cout << "dhs/dx = " << dhsdx << endl;
		cout << "dPs/dx = " << dPsdx << endl;
	}
	//-----------------------------------------------------------------------------------------	
	// Combustor
	//-----------------------------------------------------------------------------------------
	void calcDelc(real Ps, real ht, real hs, real x, real dx, real factor, int flag, int flag2) {
		
		// Test
		cout << endl;
		cout << "INPUT:  ";
		cout << "Psin = " << Ps << "  ";
		cout << "hsin = " << hs << "  ";
		cout << "htin = " << ht << endl;
		
		// etam
		etam = calcetam(x);
		// detam/dx
		detamdx = calcdetamdx(x, dx);
		
		// Test
		cout << endl;
		cout << "etam = " << etam << "  ";
		cout << "detam/dx = " << detamdx << endl;
		
		// Awall(x)
		Awall = calcAwall(x); 
		// dAwall/dx
		dAwalldx = calcdAwalldx(x);
		// Ajet 
		Ajet = Ajet3*in2cf*(1.-etam); 
		// dAjet/dx
		dAjetdx = -Ajet3*in2cf*detamdx; 
		// A
		A = Awall-Ajet;  
		// dA/dx
		dAdx = dAwalldx-dAjetdx;
		
		Fl_Otemp.copyFlow("Fl_O");
		// Burn to add fuel into flow composition, add from position x
		Fu_I.Wfuel = Wair*FAR0*calcdetamdx(x-0.5*factor*dx, dx)*dx*factor;
		Fl_Otemp.burn("Fu_I", 1.);
		// Set flow properties
		Fl_Otemp.setTotal_hP(hs/BTUcf, Ps/psicf);
		// Flow properties
		Psin = Fl_Otemp.Pt*psicf;
		hsin = Fl_Otemp.ht*BTUcf;
		Tsin = Fl_Otemp.Tt;
		Vin = (2.*(ht-hs))**0.5;
		Win = Fl_Otemp.W;
		Ain = A;
		rhoin = Fl_Otemp.rhot;
		R = Fl_Otemp.Rt*BTUcf;
		Cp = Fl_Otemp.Cpt*BTUcf;
		
		// Test
		cout << endl;
		cout << "hsin = " << hsin << "  ";
		cout << "Psin = " << Psin << "  ";
		cout << "Tsin = " << Tsin << "  ";
		cout << "Vin = " << Vin << "  ";
		cout << "Ain = " << Ain << "  ";
		cout << "rhoin = " << rhoin << "  ";
		cout << "Wfuel = " << Fl_Otemp.Wf << "  ";
		cout << "Win = " << Win << "  ";
		cout << "mu = " << Fl_Otemp.mut << endl;
		
		// Dw
		Dw = (4.*Awall/pi)**0.5;
		// Cw
		Cw = pi*Dw*dx*intoft;
		
		// Taw
		MNin = Vin/((gama*R*Tsin)**0.5);
		Taw = Tsin*(1.+Pr**(1./3.)*(0.5*(gama-1.)*(MNin**2.)));
		// Cf
		_T = 0.5*Tw+0.28*Tsin+0.22*Taw;
		_C = ((Tsin+_R)/(_T+_R))*(_T/Tsin)**0.5;
		Re = (rhoin*Vin*Dw)/Fl_Otemp.mut;
		Cf = 0.664*(_C/Re)**0.5;
		
		// Test
		cout << endl;
		cout << "T* = " << _T << "  ";
		cout << "C* = " << _C << "  ";
		cout << "Re = " << Re << "  ";
		cout << "Cf = " << Cf << endl;
		/*
		// Reynold number
		muin = Fl_Otemp.mut;
		Rein = rhoin*Vin*Dw/muin;
		// Transient Reynold
		term1 = 1.209*(10**(-4))*(MNin**2.641);
		term2 = 6.421*(e**term1);
		Retrans = 10**term2;
		// Cf and qw
		MNin = Vin/((gama*R*Tsin)**0.5);
		if (Rein >= Retrans) { 
			// Turbulent 
			Tref = 0.5*Tsin+0.5*Tw+0.5*0.16*(Pr**(1./3.))*(gama-1.)*Tsin*(MNin**2.);
			rhoref = rhoin*Tsin/Tref;
			muref = muin*((Tref/Tsin)**1.5)*((Tsin+_R)/(Tref+_R));
			Reref = rhoref*Vin*Dw/muref;
			Cf = 0.02296/(Reref**0.139);
			
			Taw = Tsin*(1.+Pr**(1./3.)*(0.5*(gama-1.)*(MNin**2.)));
			qw = 0.5*rhoin*Vin*Cp*Cf*(Tw-Taw)/(Pr**(1./3.));
		} else {
			// Laminar
			Tref = 0.45*Tsin+0.55*Tw+0.5*0.16*(Pr**(1./2.))*(gama-1.)*Tsin*(MNin**2.);
			rhoref = rhoin*Tsin/Tref;
			muref = muin*((Tref/Tsin)**1.5)*((Tsin+_R)/(Tref+_R));
			Reref = rhoref*Vin*Dw/muref;
			Cf = 0.664/(Reref**0.5);
			
			Taw = Tsin*(1.+Pr**(1./2.)*(0.5*(gama-1.)*(MNin**2.)));
			qw = 0.5*rhoin*Vin*Cp*Cf*(Tw-Taw)/(Pr**(2./3.));
		}
		
		// Test
		cout << endl;
		cout << "Cf = " << Cf << endl;
		*/
		// drhodP
		Fstemp1.copyFlow("Fl_Otemp");
		Fstemp2.copyFlow("Fl_Otemp");
		// Same phi --> same ht, same hs --> same Vin
		dP = Psin*0.001;
		Ps1 = Psin-dP;
		Ps2 = Psin+dP;
		Fstemp1.setTotal_hP(hsin/BTUcf, Ps1/psicf);
		Fstemp2.setTotal_hP(hsin/BTUcf, Ps2/psicf);
		drhodP = (Fstemp2.rhot-Fstemp1.rhot)/(2.*dP);
		// drhodh
		dh = hsin*0.001;
		hs1 = hsin-dh;
		hs2 = hsin+dh;
		Fstemp1.setTotal_hP(hs1/BTUcf, Psin/psicf);
		Fstemp2.setTotal_hP(hs2/BTUcf, Psin/psicf);
		drhodh = (Fstemp2.rhot-Fstemp1.rhot)/(2.*dh);
		// drhodphi
		if (phi0 == 0.) {
			drhodphi = 0.;
		} else {
			Fstemp1.copyFlow("Fl_Otemp");
			Fstemp2.copyFlow("Fl_Otemp");
			dphi = 0.001*FAR0/FARstoic; // 0.1; 0.01; 0.001 give close results, starts to diverge at 0.0001	
			Fu_I.Wfuel = Wair*FARstoic*dphi;
			Fstemp1.burn("Fu_I", 1.);
			Fstemp1.setTotal_hP(hsin/BTUcf, Psin/psicf);
			Fu_I.Wfuel = 2.*Wair*FARstoic*dphi;
			Fstemp2.burn("Fu_I", 1.);
			Fstemp2.setTotal_hP(hsin/BTUcf, Psin/psicf);
			drhodphi = (-3.*Fl_Otemp.rhot+4.*Fstemp1.rhot-Fstemp2.rhot)/(2.*dphi);
		}
		
		// Test
		cout << endl;
		cout << "drhodP = " << drhodP << "  ";
		cout << "drhodh = " << drhodh << "  ";
		cout << "drhodphi = " << drhodphi << endl;
		
		// dW/(W*dx)
		dWdxW = (FAR0*detamdx)/(1.+FAR0*etam);
		// Im
		term1 = -rhoin*Vin*(Vin-Vfx)*dWdxW;   
		term2 = -0.5*rhoin*(Vin**2)*Cf*Cw/(Ain*dx);
		Im = term1+term2;         
		
		// Test
		cout << endl;
		cout << "Im term1 = " << term1 << "  ";
		cout << "Im term2 = " << term2 << "  ";
		cout << "Im = " << Im << endl;
		
		// Ie
		Fstemp2.setTotal_hP(hsin/BTUcf, Psin/psicf);
		Fu_I.Wfuel = Wair*FAR0*calcdetamdx(x+0.5*dx, dx)*dx;
		Fstemp2.burn("Fu_I", 1.);
		term1 = -(Fstemp2.ht*BTUcf-hsin)/dx;
		
		term2 = qw*Cw/(Win*dx);
		
		Ie = term1+term2;
		
		// Test
		cout << endl;
		cout << "Ie term1 = " << term1 << "  ";
		cout << "Ie term2 = " << term2 << "  ";
		cout << "Ie = " << Ie << endl;
		
		// dphidx
		dphidx = (FAR0*detamdx)/FARstoic;
		// D
		term1 = 1.-(Vin**2)*drhodP;
		term2 = 1.-((Vin**2)*drhodh)/rhoin;
		term3 = ((Vin**4)*drhodP*drhodh)/rhoin;
		D = term1*term2-term3;
		// RHS1
		term1 = (rhoin*(Vin**2)*dAdx)/Ain;
		term2 = (Vin**2)*drhodphi*dphidx;
		term3 = -(rhoin*(Vin**2)*dWdxW);
		RHS1 = term1+term2+term3+Im;
		// RHS2
		term1 = ((Vin**2)*dAdx)/Ain;
		term2 = (Vin**2)*drhodphi*dphidx/rhoin;
		term3 = -(Vin**2)*dWdxW;
		RHS2 = term1+term2+term3+Ie;
		// E
		term1 = (Vin**2)*drhodP*RHS1/rhoin;
		term2 = (1.-(Vin**2)*drhodP)*RHS2;
		E = term1+term2;
		// dhs/dx
		dhsdx = E/D;
		// D and E will be different
		// E
		term1 = (Vin**2)*drhodh*dhsdx;
		E = term1+RHS1;
		// D
		D = 1.-(Vin**2)*drhodP;
		// dPs/dx
		dPsdx = E/D;
		// dht/dx
		dhtdx = Ie;
		
		// Test
		cout << endl;
		cout << "dht/dx = " << dhtdx << endl;
		cout << "dhs/dx = " << dhsdx << endl;
		cout << "dPs/dx = " << dPsdx << endl;
	}
	//-----------------------------------------------------------------------------------------	
	// 4th RK Loops
	//-----------------------------------------------------------------------------------------	
	real htintemp;
	real hsintemp;
	real Psintemp;
	
	int i;
	real k1; real k2; real k3; real k4;
	real l1; real l2; real l3; real l4;
	real m1; real m2; real m3; real m4;
	
	real hsout;
	real htout;
	real gamaout;
	real Rout;
	
	real sonicSpeed;
	// Flag for switching
	int flag;
	int flag2;
	int sos;
	//-----------------------------------------------------------------------------------------	
	// Isolator Attached Zone - 4th RK
	//-----------------------------------------------------------------------------------------	
	void RKisoatt() {
		cout << endl;
		cout << endl;
		cout << "*******************ISOLATOR ATTACHED ZONE********************" << endl;
		cout << endl;		
		for (i=0; i<Niatt; i++) {
			Psintemp = Psin;
			htintemp = htin;
			hsintemp = hsin;
			// Position
			x = x2+dxiatt*i;
			
			// Test
			cout << endl;
			cout << "*******************Position********************" << endl;
			cout << "x = " << x << endl;
			
			//-----------------------------------------------------------------------------------------
			// Step 1
			cout << endl;
			cout << "-----------------Step 1-------------------------------------------" << endl;
			calcDeliatt(Psintemp, htintemp, hsintemp, x, dxiatt);
			k1 = dPsdx;
			l1 = dhtdx;
			m1 = dhsdx;
			//-----------------------------------------------------------------------------------------
			// Step 2
			cout << endl;
			cout << "-----------------Step 2-------------------------------------------" << endl;
			calcDeliatt(Psintemp+0.5*k1*dxiatt, htintemp+0.5*l1*dxiatt, hsintemp+0.5*m1*dxiatt, x+0.5*dxiatt, dxiatt);
			k2 = dPsdx;
			l2 = dhtdx;
			m2 = dhsdx;
			//-----------------------------------------------------------------------------------------
			// Step 3
			cout << endl;
			cout << "-----------------Step 3-------------------------------------------" << endl;
			calcDeliatt(Psintemp+0.5*k2*dxiatt, htintemp+0.5*l2*dxiatt, hsintemp+0.5*m2*dxiatt, x+0.5*dxiatt, dxiatt);
			k3 = dPsdx;
			l3 = dhtdx;
			m3 = dhsdx;
			//-----------------------------------------------------------------------------------------
			// Step 4
			cout << endl;
			cout << "-----------------Step 4------------------------------------------" << endl;
			calcDeliatt(Psintemp+k3*dxiatt, htintemp+l3*dxiatt, hsintemp+m3*dxiatt, x+dxiatt, dxiatt);
			k4 = dPsdx;
			l4 = dhtdx;
			m4 = dhsdx;
			cout << endl;
			cout << "-----------------End Step------------------------------------------" << endl;
			//-----------------------------------------------------------------------------------------
			dPsdx = (k1+2.*k2+2.*k3+k4)/6.;
			dhtdx = (l1+2.*l2+2.*l3+l4)/6.;
			dhsdx = (m1+2.*m2+2.*m3+m4)/6.;
			//-----------------------------------------------------------------------------------------
			// Test
			cout << endl;
			cout << "dPsdx = " << dPsdx << endl;
			cout << "dhtdx = " << dhtdx << endl;
			cout << "dhsdx = " << dhsdx << endl;
			//-----------------------------------------------------------------------------------------	
			// Setup Fl_O with new Ps and Ts
			//-----------------------------------------------------------------------------------------	
			Psout = Psintemp+dPsdx*dxiatt;
			htout = htintemp+dhtdx*dxiatt;
			hsout = hsintemp+dhsdx*dxiatt;
			// Set Ps, ht, hs
			Vout = (2.*(htout-hsout))**0.5;
			Fl_O.setTotal_hP(hsout/BTUcf, Psout/psicf);
			Tsout = Fl_O.Tt;
			gamaout = Fl_O.gamt;
			Rout = Fl_O.Rt*BTUcf;
			sonicSpeed = (gamaout*Rout*Tsout)**0.5;
			MNout = Vout/sonicSpeed;
			
			// Test
			cout << endl;
			cout << "Psout = " << Psout << endl;
			cout << "Tsout = " << Tsout << endl;
			cout << "Vout = " << Vout << endl;
			cout << "MNout = " << MNout << endl;
			cout << endl;
			
			// Text output
			textOutputUpdate(x, dxiatt);
			//-----------------------------------------------------------------------------------------	
			// Prepare for the next iteration
			//-----------------------------------------------------------------------------------------
			Psin = Psout;
			htin = htout;
			hsin = hsout;
		} 
	}
	//-----------------------------------------------------------------------------------------	
	// Isolator Separated Zone - 4th RK
	//-----------------------------------------------------------------------------------------	
	void RKisosep() {
		cout << endl;
		cout << endl;
		cout << "*******************ISOLATOR SEPARATION ZONE********************" << endl;
		cout << endl;
		for (i=0; i<Nisep; i++) {
			Psintemp = Psin;
			htintemp = htin;
			hsintemp = hsin;
			// Position
			x = xu+dxisep*i;
			
			// Test
			cout << endl;
			cout << "*******************Position********************" << endl;
			cout << "x = " << x << endl;
			
			//-----------------------------------------------------------------------------------------
			// Step 1
			cout << endl;
			cout << "-----------------Step 1-------------------------------------------" << endl;
			calcDelisep(Psintemp, htintemp, hsintemp, x, dxisep);
			k1 = dPsdx;
			l1 = dhtdx;
			m1 = dhsdx;
			//-----------------------------------------------------------------------------------------
			// Step 2
			cout << endl;
			cout << "-----------------Step 2-------------------------------------------" << endl;
			calcDelisep(Psintemp+0.5*k1*dxisep, htintemp+0.5*l1*dxisep, hsintemp+0.5*m1*dxisep, x+0.5*dxisep, dxisep);
			k2 = dPsdx;
			l2 = dhtdx;
			m2 = dhsdx;
			//-----------------------------------------------------------------------------------------
			// Step 3
			cout << endl;
			cout << "-----------------Step 3-------------------------------------------" << endl;
			calcDelisep(Psintemp+0.5*k2*dxisep, htintemp+0.5*l2*dxisep, hsintemp+0.5*m2*dxisep, x+0.5*dxisep, dxisep);
			k3 = dPsdx;
			l3 = dhtdx;
			m3 = dhsdx;
			//-----------------------------------------------------------------------------------------
			// Step 4
			cout << endl;
			cout << "-----------------Step 4------------------------------------------" << endl;
			calcDelisep(Psintemp+k3*dxisep, htintemp+l3*dxisep, hsintemp+m3*dxisep, x+dxisep, dxisep);
			k4 = dPsdx;
			l4 = dhtdx;
			m4 = dhsdx;
			cout << endl;
			cout << "-----------------End Step------------------------------------------" << endl;
			//-----------------------------------------------------------------------------------------
			dPsdx = (k1+2.*k2+2.*k3+k4)/6.;
			dhtdx = (l1+2.*l2+2.*l3+l4)/6.;
			dhsdx = (m1+2.*m2+2.*m3+m4)/6.;
			//-----------------------------------------------------------------------------------------
			// Test
			cout << endl;
			cout << "dPsdx = " << dPsdx << endl;
			cout << "dhtdx = " << dhtdx << endl;
			cout << "dhsdx = " << dhsdx << endl;
			//-----------------------------------------------------------------------------------------	
			// Setup Fl_O with new Ps and Ts
			//-----------------------------------------------------------------------------------------	
			Psout = Psintemp+dPsdx*dxisep;
			htout = htintemp+dhtdx*dxisep;
			hsout = hsintemp+dhsdx*dxisep;
			// Set Ps, ht, hs
			Vout = (2.*(htout-hsout))**0.5;
			Fl_O.setTotal_hP(hsout/BTUcf, Psout/psicf);
			Tsout = Fl_O.Tt;
			gamaout = Fl_O.gamt;
			Rout = Fl_O.Rt*BTUcf;
			sonicSpeed = (gamaout*Rout*Tsout)**0.5;
			MNout = Vout/sonicSpeed;
			A = Fl_O.W/(Fl_O.rhot*Vout);
			
			// Test
			cout << endl;
			cout << "Psout = " << Psout << endl;
			cout << "Tsout = " << Tsout << endl;
			cout << "Vout = " << Vout << endl;
			cout << "MNout = " << MNout << endl;
			cout << endl;
			
			// Text output
			textOutputUpdate(x, dxisep);
			//-----------------------------------------------------------------------------------------	
			// Prepare for the next iteration
			//-----------------------------------------------------------------------------------------
			Psin = Psout;
			htin = htout;
			hsin = hsout;
		} 
	}
	//-----------------------------------------------------------------------------------------	
	// Combustor - 4th RK
	//-----------------------------------------------------------------------------------------	
	void RKc() {
		cout << endl;
		cout << endl;
		cout << "*******************COMBUSTOR********************" << endl;
		cout << endl;
		flag = 0; 
		flag2 = 0;
		for (i=0; i<Nc; i++) {
			Psintemp = Psin;
			htintemp = htin;
			hsintemp = hsin;
			// Position
			x = x3+dxc*i;
			
			// Test
			cout << endl;
			cout << "*******************Position********************" << endl;
			cout << "x = " << x << endl;
			
			//-----------------------------------------------------------------------------------------
			// Step 1
			cout << endl;
			cout << "-----------------Step 1-------------------------------------------" << endl;
			calcDelc(Psintemp, htintemp, hsintemp, x, dxc, 0., flag, flag2);
			k1 = dPsdx;
			l1 = dhtdx;
			m1 = dhsdx;
			//-----------------------------------------------------------------------------------------
			// Step 2
			cout << endl;
			cout << "-----------------Step 2-------------------------------------------" << endl;
			calcDelc(Psintemp+0.5*k1*dxc, htintemp+0.5*l1*dxc, hsintemp+0.5*m1*dxc, x+0.5*dxc, dxc, 0.5, flag, flag2);
			k2 = dPsdx;
			l2 = dhtdx;
			m2 = dhsdx;
			//-----------------------------------------------------------------------------------------
			// Step 3
			cout << endl;
			cout << "-----------------Step 3-------------------------------------------" << endl;
			calcDelc(Psintemp+0.5*k2*dxc, htintemp+0.5*l2*dxc, hsintemp+0.5*m2*dxc, x+0.5*dxc, dxc, 0.5, flag, flag2);
			k3 = dPsdx;
			l3 = dhtdx;
			m3 = dhsdx;
			//-----------------------------------------------------------------------------------------
			// Step 4
			cout << endl;
			cout << "-----------------Step 4------------------------------------------" << endl;
			calcDelc(Psintemp+k3*dxc, htintemp+l3*dxc, hsintemp+m3*dxc, x+dxc, dxc, 1., flag, flag2);
			k4 = dPsdx;
			l4 = dhtdx;
			m4 = dhsdx;
			cout << endl;
			cout << "-----------------End Step------------------------------------------" << endl;
			//-----------------------------------------------------------------------------------------
			dPsdx = (k1+2.*k2+2.*k3+k4)/6.;
			dhtdx = (l1+2.*l2+2.*l3+l4)/6.;
			dhsdx = (m1+2.*m2+2.*m3+m4)/6.;
			//-----------------------------------------------------------------------------------------
			// Test
			cout << endl;
			cout << "dPsdx = " << dPsdx << endl;
			cout << "dhtdx = " << dhtdx << endl;
			cout << "dhsdx = " << dhsdx << endl;
			//-----------------------------------------------------------------------------------------	
			// Setup Fl_O with new Ps and Ts
			//-----------------------------------------------------------------------------------------	
			Psout = Psintemp+dPsdx*dxc;
			htout = htintemp+dhtdx*dxc;
			hsout = hsintemp+dhsdx*dxc;
			// Burn
			detamdx = calcdetamdx(x+0.5*dxc, dxc); 
			Fu_I.Wfuel = Wair*FAR0*detamdx*dxc;
			Fl_O.burn("Fu_I", 1.);
			// Set Ps, ht, hs
			Vout = (2.*(htout-hsout))**0.5;
			Fl_O.setTotal_hP(hsout/BTUcf, Psout/psicf);
			Tsout = Fl_O.Tt;
			gamaout = Fl_O.gamt;
			Rout = Fl_O.Rt*BTUcf;
			sonicSpeed = (gamaout*Rout*Tsout)**0.5;
			MNout = Vout/sonicSpeed;
			
			// Test
			cout << endl;
			cout << "Psout = " << Psout << endl;
			cout << "Tsout = " << Tsout << endl;
			cout << "Vout = " << Vout << endl;
			cout << "MNout = " << MNout << endl;
			cout << "Flag = " << flag << endl;
			cout << "Flag2 = " << flag2 << endl;
			cout << endl;
	
			// Text output
			textOutputUpdate(x, dxc);
			//-----------------------------------------------------------------------------------------	
			// Prepare for the next iteration
			//-----------------------------------------------------------------------------------------
			Psin = Psout;
			htin = htout;
			hsin = hsout;
		}
	}
	//-----------------------------------------------------------------------------------------	
	// Main Program
	//-----------------------------------------------------------------------------------------	
	real x;
	real x2 = 0.;
	real xu;
	real x3 = x2+Li;
	real x4 = x3+Lc;
	real dxiatt;
	real dxisep;
	real dxc = (x4-x3)/Nc;
	
	initiate();
	textinitiate();
	// Fisher
	/*
	xu = 0.155*mtoin;
	dxiatt = (xu-x2)/Niatt;
	dxisep = (x3-xu)/Nisep;
	RKisoatt();
	RKisosep();
	*/
	// Boyce and Hyshot

	Vfx = calcVfx();
	Lmix = calcLmix();
	RKc();

	//Fl_O.setTotal_hsPsV(hsout/BTUcf, Psout/psicf, Vout);
  }
  //------------------------------------------------------------
  // register the appropriate errors at build time
  //------------------------------------------------------------
  void VCinit()
  {
    ESOregCreate( 1023901, 8, "", TRUE, FALSE, TRUE ); // provisional
    ESOregCreate( 1093901, 8, "", TRUE, FALSE, TRUE ); // provisional
  }
}
#endif